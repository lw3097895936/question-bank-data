{
  "version": "1.0.0",
  "lastUpdate": "2024-01-15",
  "category": "Go",
  "topics": [
    {
      "id": "basic",
      "name": "基础语法专题",
      "questions": [
        {
          "id": 1,
          "title": "Go中的goroutine和channel？",
          "answer": "【Goroutine】\nGoroutine是Go语言的轻量级线程，由Go运行时管理。\n\n【特点】\n- 轻量级：初始栈大小只有2KB\n- 并发：可以同时运行成千上万个goroutine\n- 简单：使用go关键字启动\n\n【基本使用】\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"world\")  // 启动goroutine\n    say(\"hello\")     // 主goroutine\n}\n```\n\n【Channel】\nChannel是Go语言中用于goroutine间通信的管道。\n\n【基本语法】\n```go\n// 创建channel\nch := make(chan int)        // 无缓冲channel\nch := make(chan int, 10)    // 有缓冲channel\n\n// 发送数据\nch <- 42\n\n// 接收数据\nvalue := <-ch\n```\n\n【无缓冲vs有缓冲】\n```go\n// 无缓冲channel - 同步通信\nch := make(chan int)\ngo func() {\n    ch <- 42  // 发送\n}()\nvalue := <-ch  // 接收\n\n// 有缓冲channel - 异步通信\nch := make(chan int, 1)\nch <- 42  // 不会阻塞\nvalue := <-ch\n```\n\n【Select语句】\n```go\nselect {\ncase msg1 := <-ch1:\n    fmt.Println(\"Received from ch1:\", msg1)\ncase msg2 := <-ch2:\n    fmt.Println(\"Received from ch2:\", msg2)\ncase ch3 <- 42:\n    fmt.Println(\"Sent to ch3\")\ndefault:\n    fmt.Println(\"No communication\")\n}\n```\n\n【实际应用】\n```go\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n    for j := range jobs {\n        fmt.Printf(\"worker %d processing job %d\\n\", id, j)\n        time.Sleep(time.Second)\n        results <- j * 2\n    }\n}\n\nfunc main() {\n    jobs := make(chan int, 100)\n    results := make(chan int, 100)\n    \n    // 启动3个worker\n    for w := 1; w <= 3; w++ {\n        go worker(w, jobs, results)\n    }\n    \n    // 发送任务\n    for j := 1; j <= 9; j++ {\n        jobs <- j\n    }\n    close(jobs)\n    \n    // 收集结果\n    for a := 1; a <= 9; a++ {\n        <-results\n    }\n}\n```"
        },
        {
          "id": 2,
          "title": "Go中的接口和结构体？",
          "answer": "【接口(Interface)】\nGo的接口是隐式实现的，只要类型实现了接口的所有方法，就认为实现了该接口。\n\n【基本语法】\n```go\ntype Animal interface {\n    Speak() string\n    Move() string\n}\n\ntype Dog struct {\n    Name string\n}\n\nfunc (d Dog) Speak() string {\n    return \"Woof!\"\n}\n\nfunc (d Dog) Move() string {\n    return \"Running\"\n}\n\n// Dog自动实现了Animal接口\nfunc main() {\n    var animal Animal = Dog{\"Buddy\"}\n    fmt.Println(animal.Speak())\n    fmt.Println(animal.Move())\n}\n```\n\n【空接口】\n```go\n// interface{} 可以接受任何类型\nfunc printAnything(v interface{}) {\n    fmt.Printf(\"Value: %v, Type: %T\\n\", v, v)\n}\n\nfunc main() {\n    printAnything(42)\n    printAnything(\"hello\")\n    printAnything(true)\n}\n```\n\n【类型断言】\n```go\nfunc processValue(v interface{}) {\n    // 类型断言\n    if str, ok := v.(string); ok {\n        fmt.Printf(\"String: %s\\n\", str)\n    } else if num, ok := v.(int); ok {\n        fmt.Printf(\"Number: %d\\n\", num)\n    } else {\n        fmt.Printf(\"Unknown type: %T\\n\", v)\n    }\n}\n\n// 类型开关\nfunc processValueSwitch(v interface{}) {\n    switch value := v.(type) {\n    case string:\n        fmt.Printf(\"String: %s\\n\", value)\n    case int:\n        fmt.Printf(\"Number: %d\\n\", value)\n    default:\n        fmt.Printf(\"Unknown type: %T\\n\", value)\n    }\n}\n```\n\n【结构体嵌入】\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) Introduce() string {\n    return fmt.Sprintf(\"I'm %s, %d years old\", p.Name, p.Age)\n}\n\ntype Employee struct {\n    Person      // 嵌入Person\n    Company string\n}\n\nfunc main() {\n    emp := Employee{\n        Person:  Person{\"Alice\", 30},\n        Company: \"Tech Corp\",\n    }\n    \n    // 可以直接调用Person的方法\n    fmt.Println(emp.Introduce())\n    fmt.Println(emp.Name)  // 直接访问Person的字段\n}\n```\n\n【接口组合】\n```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// 等价于\n// type ReadWriter interface {\n//     Read(p []byte) (n int, err error)\n//     Write(p []byte) (n int, err error)\n// }\n```"
        },
        {
          "id": 3,
          "title": "Go中的错误处理？",
          "answer": "【错误处理原则】\nGo语言使用返回值而不是异常来处理错误。\n\n【基本模式】\n```go\nfunc divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, fmt.Errorf(\"division by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    result, err := divide(10, 0)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n        return\n    }\n    fmt.Printf(\"Result: %d\\n\", result)\n}\n```\n\n【自定义错误类型】\n```go\ntype ValidationError struct {\n    Field string\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error on field %s: %s\", e.Field, e.Message)\n}\n\nfunc validateAge(age int) error {\n    if age < 0 {\n        return ValidationError{\n            Field:   \"age\",\n            Message: \"age cannot be negative\",\n        }\n    }\n    if age > 150 {\n        return ValidationError{\n            Field:   \"age\",\n            Message: \"age cannot be greater than 150\",\n        }\n    }\n    return nil\n}\n```\n\n【错误包装】\n```go\nimport \"fmt\"\n\nfunc processUser(id int) error {\n    user, err := getUser(id)\n    if err != nil {\n        return fmt.Errorf(\"failed to process user %d: %w\", id, err)\n    }\n    return nil\n}\n\nfunc getUser(id int) (User, error) {\n    // 模拟错误\n    return User{}, fmt.Errorf(\"user not found\")\n}\n\n// 错误解包\nfunc main() {\n    err := processUser(123)\n    if err != nil {\n        fmt.Printf(\"Error: %v\\n\", err)\n        \n        // 检查是否是特定错误\n        if errors.Is(err, ErrUserNotFound) {\n            fmt.Println(\"User not found\")\n        }\n    }\n}\n```\n\n【Panic和Recover】\n```go\nfunc recoverExample() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Printf(\"Recovered from panic: %v\\n\", r)\n        }\n    }()\n    \n    panic(\"something went wrong\")\n}\n\nfunc main() {\n    recoverExample()\n    fmt.Println(\"Program continues...\")\n}\n```\n\n【最佳实践】\n```go\n// 1. 总是检查错误\nresult, err := someFunction()\nif err != nil {\n    return err\n}\n\n// 2. 使用有意义的错误信息\nif age < 0 {\n    return fmt.Errorf(\"invalid age: %d (must be positive)\", age)\n}\n\n// 3. 避免忽略错误\n_ = someFunction()  // 不好的做法\n\n// 4. 使用errors.Is和errors.As进行错误比较\nif errors.Is(err, sql.ErrNoRows) {\n    // 处理特定错误\n}\n\nvar validationErr ValidationError\nif errors.As(err, &validationErr) {\n    // 处理验证错误\n}\n```"
        }
      ]
    }
  ]
} 