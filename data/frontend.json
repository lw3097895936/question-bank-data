{
  "version": "1.0.0",
  "lastUpdate": "2024-01-15",
  "category": "前端",
  "topics": [
    {
      "id": "html-css",
      "name": "HTML/CSS专题",
      "questions": [
        { "id": 1, "title": "HTML5 新特性有哪些？", "answer": "【HTML5新特性】\n1. 语义化标签：header、nav、main、article、section、aside、footer等\n2. 表单增强：input类型（email、url、date、time、number等）、required、pattern属性\n3. 多媒体：video、audio标签，支持原生播放\n4. Canvas绘图：2D绘图API，可绘制图形、动画\n5. WebGL：3D图形渲染\n6. 本地存储：localStorage、sessionStorage\n7. Web Workers：后台线程处理\n8. WebSocket：全双工通信\n9. 地理定位：Geolocation API\n10. 拖拽API：Drag and Drop\n【实际应用】\n- 语义化提升SEO和可访问性\n- Canvas用于数据可视化、游戏开发\n- 本地存储用于缓存用户数据" },
        { "id": 2, "title": "CSS Flex 和 Grid 布局的区别？", "answer": "【Flex布局】\n- 一维布局，主要处理行或列的排列\n- 适合导航栏、卡片列表等线性布局\n- 属性：flex-direction、justify-content、align-items、flex-wrap\n\n【Grid布局】\n- 二维布局，同时处理行和列\n- 适合页面整体布局、表格等\n- 属性：grid-template-columns、grid-template-rows、grid-area\n\n【选择建议】\n- 简单线性布局用Flex\n- 复杂二维布局用Grid\n- 两者可以结合使用" },
        { "id": 3, "title": "如何实现响应式布局？", "answer": "【响应式布局方案】\n1. 媒体查询：@media screen and (max-width: 768px)\n2. 弹性布局：Flexbox、Grid\n3. 相对单位：rem、em、%、vw/vh\n4. 图片适配：max-width: 100%、object-fit\n5. 断点设计：移动端(320px)、平板(768px)、桌面(1024px)\n\n【最佳实践】\n- 移动优先设计\n- 使用相对单位\n- 设置合理的断点\n- 测试不同设备" },
        { "id": 4, "title": "移动端适配常见方案？", "answer": "【移动端适配方案】\n1. viewport设置：<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n2. rem适配：根据屏幕宽度动态设置根字体大小\n3. vw/vh适配：视口单位，1vw = 视口宽度的1%\n4. 媒体查询：针对不同屏幕尺寸设置样式\n5. 弹性图片：max-width: 100%\n6. 触摸优化：增大点击区域、禁用双击缩放\n\n【实际应用】\n- 电商网站需要适配各种手机屏幕\n- 游戏界面需要适配不同分辨率" }
      ]
    },
    {
      "id": "javascript",
      "name": "JavaScript专题",
      "questions": [
        { "id": 5, "title": "JavaScript 事件委托是什么？", "answer": "【事件委托原理】\n事件委托利用事件冒泡机制，将事件监听器绑定到父元素上，通过event.target判断具体触发事件的子元素。\n\n【优势】\n1. 减少内存占用：不需要为每个子元素绑定事件\n2. 动态元素支持：新增元素自动具有事件处理能力\n3. 性能优化：减少事件监听器数量\n\n【代码示例】\n```javascript\n// 传统方式\nlist.forEach(item => item.addEventListener(\"click\", handleClick));\n\n// 事件委托\nlist.addEventListener(\"click\", (e) => {\n  if (e.target.matches(\".item\")) {\n    handleClick(e);\n  }\n});\n```\n\n【应用场景】\n- 列表项点击处理\n- 表格行操作\n- 动态内容交互" },
        { "id": 6, "title": "闭包的原理和应用场景？", "answer": "【闭包原理】\n闭包是指函数能够访问其词法作用域之外的变量，即使函数在原始作用域之外执行。\n\n【形成条件】\n1. 函数嵌套\n2. 内部函数引用外部变量\n3. 内部函数被外部引用\n\n【应用场景】\n1. 数据私有化：创建私有变量\n2. 函数工厂：创建特定功能的函数\n3. 模块化：实现模块模式\n4. 回调函数：保持状态\n\n【代码示例】\n```javascript\nfunction createCounter() {\n  let count = 0;\n  return {\n    increment: () => ++count,\n    getCount: () => count\n  };\n}\n```\n\n【注意事项】\n- 内存泄漏风险\n- 循环引用问题" },
        { "id": 7, "title": "Promise、async/await 的区别和原理？", "answer": "【Promise原理】\nPromise是异步编程的解决方案，有三种状态：pending、fulfilled、rejected。\n\n【async/await原理】\nasync/await是Promise的语法糖，让异步代码看起来像同步代码。\n\n【区别对比】\n1. 语法：async/await更简洁易读\n2. 错误处理：async/await可以用try-catch\n3. 调试：async/await更容易调试\n4. 兼容性：Promise兼容性更好\n\n【代码示例】\n```javascript\n// Promise\nfetch(url)\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n\n// async/await\ntry {\n  const res = await fetch(url);\n  const data = await res.json();\n  console.log(data);\n} catch (err) {\n  console.error(err);\n}\n```" },
        { "id": 8, "title": "前端路由实现原理？", "answer": "【路由实现原理】\n前端路由通过监听URL变化，动态渲染对应的组件，实现SPA（单页应用）。\n\n【实现方式】\n1. Hash路由：监听hashchange事件\n2. History路由：使用History API\n\n【Hash路由】\n```javascript\n// 监听hash变化\nwindow.addEventListener(\"hashchange\", () => {\n  const hash = location.hash.slice(1);\n  renderComponent(hash);\n});\n```\n\n【History路由】\n```javascript\n// 监听popstate事件\nwindow.addEventListener(\"popstate\", () => {\n  const path = location.pathname;\n  renderComponent(path);\n});\n\n// 编程式导航\nhistory.pushState({}, \"\", \"/new-path\");\n```\n\n【优缺点】\n- Hash：兼容性好，但URL不美观\n- History：URL美观，但需要服务器配置" },
        { "id": 9, "title": "JavaScript 中的原型链是什么？", "answer": "【原型链原理】\n原型链是JavaScript实现继承的机制，每个对象都有一个原型对象，对象从原型继承属性和方法。\n\n【原型链查找】\n1. 对象查找属性时，先在自身查找\n2. 找不到则查找原型对象\n3. 原型对象也有原型，形成链式查找\n4. 最终找到Object.prototype，再往上为null\n\n【代码示例】\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, ${this.name}`);\n};\n\nconst person = new Person('Alice');\nperson.sayHello(); // 通过原型链找到sayHello方法\n```\n\n【实际应用】\n- 实现继承\n- 方法共享\n- 属性查找\n- 原型污染防护" },
        { "id": 10, "title": "防抖和节流的区别及实现？", "answer": "【防抖(Debounce)】\n在一定时间内，多次触发同一事件，只执行最后一次。\n\n【节流(Throttle)】\n在一定时间内，多次触发同一事件，按固定频率执行。\n\n【代码实现】\n```javascript\n// 防抖\nfunction debounce(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n\n// 节流\nfunction throttle(fn, delay) {\n  let last = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - last >= delay) {\n      fn.apply(this, args);\n      last = now;\n    }\n  };\n}\n```\n\n【应用场景】\n- 防抖：搜索输入、窗口调整\n- 节流：滚动事件、按钮点击" },
        { "id": 11, "title": "JavaScript 中的 this 指向问题？", "answer": "【this指向规则】\n1. 全局环境：指向window/global\n2. 对象方法：指向调用对象\n3. 构造函数：指向新创建实例\n4. 箭头函数：指向外层作用域\n5. 事件处理：指向触发元素\n\n【代码示例】\n```javascript\n// 对象方法\nconst obj = {\n  name: 'Alice',\n  sayName() {\n    console.log(this.name); // this指向obj\n  }\n};\n\n// 箭头函数\nconst arrowFn = () => {\n  console.log(this); // this指向外层作用域\n};\n\n// 构造函数\nfunction Person(name) {\n  this.name = name; // this指向新实例\n}\n```\n\n【常见陷阱】\n- 回调函数中的this\n- 定时器中的this\n- 事件处理中的this" },
        { "id": 12, "title": "JavaScript 中的事件循环机制？", "answer": "【事件循环原理】\nJavaScript是单线程语言，通过事件循环处理异步任务。\n\n【执行顺序】\n1. 同步代码立即执行\n2. 异步任务放入任务队列\n3. 微任务优先于宏任务执行\n4. 宏任务按顺序执行\n\n【任务分类】\n- 宏任务：setTimeout、setInterval、I/O\n- 微任务：Promise.then、process.nextTick\n\n【代码示例】\n```javascript\nconsole.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');\n// 输出顺序：1, 4, 3, 2\n```\n\n【实际应用】\n- 理解异步执行顺序\n- 避免阻塞主线程\n- 优化性能" },
        { "id": 13, "title": "JavaScript 中的模块化方案？", "answer": "【模块化方案】\n1. CommonJS：Node.js使用，同步加载\n2. AMD：RequireJS，异步加载\n3. ES6 Modules：原生支持，静态导入\n4. UMD：通用模块定义\n\n【ES6 Modules】\n```javascript\n// 导出\nexport const name = 'Alice';\nexport function sayHello() {\n  console.log('Hello');\n}\nexport default class Person {}\n\n// 导入\nimport { name, sayHello } from './module.js';\nimport Person from './person.js';\n```\n\n【优势】\n- 静态分析\n- 树摇优化\n- 循环依赖检测\n- 更好的封装性" },
        { "id": 14, "title": "React Hooks 的使用规则和原理？", "answer": "【Hooks使用规则】\n1. 只能在函数组件顶层调用\n2. 不能在循环、条件、嵌套函数中调用\n3. 只能在React函数组件或自定义Hook中调用\n\n【常用Hooks】\n```javascript\n// useState\nconst [count, setCount] = useState(0);\n\n// useEffect\nuseEffect(() => {\n  // 副作用逻辑\n  return () => {\n    // 清理逻辑\n  };\n}, [dependencies]);\n\n// useContext\nconst theme = useContext(ThemeContext);\n\n// useReducer\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\n【原理】\n- 基于链表结构存储状态\n- 调用顺序决定状态对应关系\n- 依赖数组控制执行时机\n\n【最佳实践】\n- 合理使用依赖数组\n- 避免过度使用useEffect\n- 自定义Hook封装逻辑" },
        { "id": 15, "title": "Vue3 Composition API 的优势？", "answer": "【Composition API优势】\n1. 更好的逻辑复用：函数式编程\n2. 更好的类型推导：TypeScript支持\n3. 更小的打包体积：Tree-shaking\n4. 更好的性能：响应式系统优化\n\n【代码对比】\n```javascript\n// Options API\nexport default {\n  data() {\n    return { count: 0 };\n  },\n  methods: {\n    increment() {\n      this.count++;\n    }\n  }\n};\n\n// Composition API\nimport { ref } from 'vue';\nexport default {\n  setup() {\n    const count = ref(0);\n    const increment = () => count.value++;\n    return { count, increment };\n  }\n};\n```\n\n【核心特性】\n- ref/reactive：响应式数据\n- computed：计算属性\n- watch/watchEffect：侦听器\n- provide/inject：依赖注入\n\n【实际应用】\n- 复杂组件逻辑拆分\n- 跨组件逻辑复用\n- 更好的代码组织" },
        { "id": 16, "title": "前端框架的虚拟DOM原理？", "answer": "【虚拟DOM原理】\n虚拟DOM是真实DOM的JavaScript对象表示，用于优化DOM操作。\n\n【工作流程】\n1. 状态变化时生成新的虚拟DOM\n2. 对比新旧虚拟DOM的差异\n3. 将差异应用到真实DOM\n4. 批量更新减少重排重绘\n\n【Diff算法】\n```javascript\n// 简单Diff示例\nfunction diff(oldVNode, newVNode) {\n  if (oldVNode.type !== newVNode.type) {\n    // 类型不同，直接替换\n    return { type: 'REPLACE', node: newVNode };\n  }\n  \n  if (typeof newVNode === 'string') {\n    // 文本节点\n    return oldVNode !== newVNode ? \n      { type: 'TEXT', content: newVNode } : null;\n  }\n  \n  // 属性对比\n  const propsPatch = diffProps(oldVNode.props, newVNode.props);\n  \n  // 子节点对比\n  const childrenPatch = diffChildren(oldVNode.children, newVNode.children);\n  \n  return { propsPatch, childrenPatch };\n}\n```\n\n【优化策略】\n- 同层比较\n- Key优化\n- 组件级别更新\n- 批量处理" }
      ]
    },
    {
      "id": "performance",
      "name": "性能优化专题",
      "questions": [
        { "id": 17, "title": "前端性能优化常见手段有哪些？", "answer": "【前端性能优化手段】\n1. 资源优化\n   - 图片压缩、WebP格式、懒加载\n   - CSS/JS压缩、合并、CDN加速\n   - 字体文件优化、图标字体\n\n2. 加载优化\n   - 代码分割、懒加载\n   - 预加载、预连接\n   - 缓存策略（强缓存、协商缓存）\n\n3. 渲染优化\n   - 虚拟滚动、防抖节流\n   - 避免重排重绘\n   - 使用transform、opacity等GPU加速\n\n4. 网络优化\n   - HTTP/2、HTTP/3\n   - 服务端渲染(SSR)\n   - 静态资源优化\n\n【性能指标】\n- FCP (First Contentful Paint)\n- LCP (Largest Contentful Paint)\n- FID (First Input Delay)\n- CLS (Cumulative Layout Shift)\n\n【工具】\n- Lighthouse、WebPageTest\n- Chrome DevTools Performance\n- 真实用户监控(RUM)" },
        { "id": 18, "title": "前端如何做代码分割与懒加载？", "answer": "【代码分割策略】\n1. 路由分割：按路由分割代码\n2. 组件分割：按需加载组件\n3. 第三方库分割：vendor chunk\n4. 动态导入：import()语法\n\n【懒加载实现】\n```javascript\n// React懒加载\nconst LazyComponent = React.lazy(() => import(\"./LazyComponent\"));\n\n// Vue懒加载\nconst LazyComponent = () => import(\"./LazyComponent.vue\");\n\n// 图片懒加载\nconst observer = new IntersectionObserver((entries) => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      entry.target.src = entry.target.dataset.src;\n    }\n  });\n});\n```\n\n【Webpack配置】\n```javascript\n// 动态导入\nimport(/* webpackChunkName: \"chunk-name\" */ \"./module\");\n\n// 分包配置\noptimization: {\n  splitChunks: {\n    chunks: \"all\",\n    cacheGroups: {\n      vendor: {\n        test: /[\\\\/]node_modules[\\\\/]/,\n        name: \"vendors\"\n      }\n    }\n  }\n}\n```\n\n【最佳实践】\n- 合理设置分割粒度\n- 避免过度分割\n- 监控包大小" },
        { "id": 19, "title": "Webpack/Vite 的核心原理？", "answer": "【Webpack核心原理】\n1. 模块化：将一切文件视为模块\n2. 依赖图：构建模块依赖关系图\n3. 加载器：处理不同类型文件\n4. 插件系统：扩展构建功能\n5. 输出：生成最终文件\n\n【Vite核心原理】\n1. 开发环境：ES模块 + 浏览器原生支持\n2. 生产环境：Rollup打包\n3. 热更新：HMR (Hot Module Replacement)\n4. 预构建：依赖预构建提升速度\n\n【主要区别】\n1. 开发速度：Vite更快（无需打包）\n2. 配置复杂度：Vite更简单\n3. 生态：Webpack更成熟\n4. 构建速度：Vite更快\n\n【Webpack工作流程】\n1. 解析配置\n2. 开始编译\n3. 确定入口\n4. 编译模块\n5. 完成编译\n6. 输出资源\n\n【Vite优势】\n- 冷启动快\n- 热更新快\n- 配置简单\n- 原生ES模块支持" },
        { "id": 20, "title": "前端缓存策略有哪些？", "answer": "【缓存策略】\n1. 强缓存：Cache-Control、Expires\n2. 协商缓存：ETag、Last-Modified\n3. 浏览器缓存：localStorage、sessionStorage\n4. 应用缓存：Service Worker\n\n【HTTP缓存头】\n```javascript\n// 强缓存\nres.setHeader('Cache-Control', 'max-age=31536000');\nres.setHeader('Expires', new Date(Date.now() + 31536000000));\n\n// 协商缓存\nres.setHeader('ETag', etag);\nres.setHeader('Last-Modified', lastModified);\n```\n\n【Service Worker】\n```javascript\n// 注册Service Worker\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js');\n}\n\n// 缓存策略\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => response || fetch(event.request))\n  );\n});\n```\n\n【最佳实践】\n- 静态资源长期缓存\n- 动态内容协商缓存\n- 离线功能支持\n- 缓存版本控制" },
        { "id": 21, "title": "前端监控和错误追踪？", "answer": "【监控指标】\n1. 性能指标：FCP、LCP、FID、CLS\n2. 错误指标：JS错误、API错误\n3. 用户行为：PV、UV、点击路径\n4. 业务指标：转化率、留存率\n\n【错误监控】\n```javascript\n// 全局错误捕获\nwindow.addEventListener('error', (event) => {\n  console.error('JS Error:', event.error);\n  // 上报错误信息\n  reportError({\n    message: event.message,\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    stack: event.error?.stack\n  });\n});\n\n// Promise错误捕获\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Promise Error:', event.reason);\n  reportError({\n    type: 'promise',\n    reason: event.reason\n  });\n});\n```\n\n【性能监控】\n```javascript\n// 性能指标\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    console.log(entry.name, entry.startTime);\n  }\n});\nobserver.observe({ entryTypes: ['navigation', 'resource'] });\n```\n\n【工具推荐】\n- Sentry：错误监控\n- Google Analytics：用户行为\n- 自建监控系统：定制化需求" }
      ]
    },
    {
      "id": "security-test",
      "name": "安全与测试专题",
      "questions": [
        { "id": 22, "title": "前端安全（XSS、CSRF）如何防护？", "answer": "【XSS防护】\n1. 输入过滤：对用户输入进行HTML编码\n2. 输出编码：使用innerText而不是innerHTML\n3. CSP策略：Content Security Policy\n4. HttpOnly Cookie：防止JS访问敏感Cookie\n\n【CSRF防护】\n1. Token验证：服务端生成随机Token\n2. SameSite Cookie：设置Cookie的SameSite属性\n3. Referer检查：验证请求来源\n4. 双重Cookie验证\n\n【代码示例】\n```javascript\n// XSS防护\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n// CSRF Token\nconst token = document.querySelector(\"meta[name=csrf-token]\").content;\nfetch(\"/api/data\", {\n  headers: { \"X-CSRF-Token\": token }\n});\n```\n\n【其他安全措施】\n- HTTPS强制\n- 输入验证\n- 权限控制\n- 日志监控" },
        { "id": 23, "title": "前端自动化测试工具有哪些？", "answer": "【单元测试】\n1. Jest：Facebook开发的测试框架\n2. Vitest：Vite生态的测试工具\n3. Mocha + Chai：灵活的测试组合\n4. Jasmine：BDD风格的测试框架\n\n【组件测试】\n1. React Testing Library：React组件测试\n2. Vue Test Utils：Vue组件测试\n3. Cypress Component Testing：组件E2E测试\n\n【E2E测试】\n1. Cypress：现代化的E2E测试工具\n2. Playwright：微软开发的测试工具\n3. Selenium：传统的自动化测试\n4. Puppeteer：Chrome自动化\n\n【测试最佳实践】\n```javascript\n// Jest示例\ndescribe(\"Calculator\", () => {\n  test(\"adds two numbers\", () => {\n    expect(add(1, 2)).toBe(3);\n  });\n});\n\n// React Testing Library\ntest(\"renders button\", () => {\n  render(<Button>Click me</Button>);\n  expect(screen.getByText(\"Click me\")).toBeInTheDocument();\n});\n```\n\n【测试策略】\n- 单元测试覆盖核心逻辑\n- 集成测试验证组件交互\n- E2E测试保证用户流程" },
        { "id": 24, "title": "前端如何做SEO优化？", "answer": "【SEO优化要点】\n1. 语义化HTML：使用正确的标签结构\n2. Meta标签：title、description、keywords\n3. 结构化数据：JSON-LD、Microdata\n4. 图片优化：alt属性、压缩图片\n5. 内部链接：合理的链接结构\n6. 页面速度：优化加载性能\n\n【技术实现】\n```html\n<!-- Meta标签 -->\n<title>页面标题</title>\n<meta name=\"description\" content=\"页面描述\">\n<meta name=\"keywords\" content=\"关键词\">\n\n<!-- 结构化数据 -->\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Article\",\n  \"headline\": \"文章标题\"\n}\n</script>\n```\n\n【SPA SEO】\n1. 服务端渲染(SSR)\n2. 预渲染(Prerendering)\n3. 动态渲染\n4. 路由优化\n\n【工具】\n- Google Search Console\n- Lighthouse SEO审计\n- Screaming Frog\n- SEMrush" },
        { "id": 25, "title": "前端如何做国际化(i18n)？", "answer": "【国际化方案】\n1. 文本翻译：使用翻译文件\n2. 数字格式化：货币、日期、时间\n3. 方向适配：RTL语言支持\n4. 图片本地化：文化适配\n\n【技术实现】\n```javascript\n// react-i18next\nimport { useTranslation } from \"react-i18next\";\n\nfunction Component() {\n  const { t } = useTranslation();\n  return <h1>{t(\"welcome\")}</h1>;\n}\n\n// Vue i18n\n<template>\n  <h1>{{ $t(\"welcome\") }}</h1>\n</template>\n```\n\n【翻译文件结构】\n```json\n{\n  \"zh\": {\n    \"welcome\": \"欢迎\",\n    \"user\": {\n      \"name\": \"姓名\",\n      \"email\": \"邮箱\"\n    }\n  },\n  \"en\": {\n    \"welcome\": \"Welcome\",\n    \"user\": {\n      \"name\": \"Name\",\n      \"email\": \"Email\"\n    }\n  }\n}\n```\n\n【最佳实践】\n- 使用key而不是硬编码文本\n- 考虑文本长度变化\n- 支持复数形式\n- 文化差异适配" },
        { "id": 26, "title": "小程序和H5的区别？", "answer": "【技术架构】\n1. 小程序：基于微信/支付宝等平台\n2. H5：基于浏览器环境\n\n【开发差异】\n1. 语言：小程序用WXML/WXSS，H5用HTML/CSS\n2. 框架：小程序有生命周期，H5更灵活\n3. 组件：小程序有内置组件，H5需要自己实现\n4. API：小程序有平台API，H5用Web API\n\n【性能对比】\n1. 启动速度：小程序更快（预加载）\n2. 渲染性能：小程序更好（原生渲染）\n3. 网络请求：小程序有域名白名单限制\n4. 存储：小程序有存储限制\n\n【用户体验】\n1. 安装：小程序无需安装，H5直接访问\n2. 分享：小程序分享更方便\n3. 支付：小程序支付体验更好\n4. 权限：小程序权限管理更严格\n\n【选择建议】\n- 需要原生体验选小程序\n- 需要跨平台选H5\n- 考虑用户使用习惯" }
      ]
    }
  ]
} 