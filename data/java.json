{
  "version": "1.0.0",
  "lastUpdate": "2024-01-15",
  "category": "Java基础",
  "topics": [
    {
      "id": "basic",
      "name": "基础语法专题",
      "questions": [
        {
          "id": 1,
          "title": "Java 基础语法和数据类型？",
          "answer": "【Java基础语法】\n1. 标识符：字母、数字、下划线、$组成，不能以数字开头\n2. 关键字：public、class、static、final等\n3. 注释：// 单行注释、/* */ 多行注释、/** */ 文档注释\n4. 语句：以分号结尾\n\n【数据类型】\n1. 基本数据类型（8种）：\n   - 整数：byte(8位)、short(16位)、int(32位)、long(64位)\n   - 浮点：float(32位)、double(64位)\n   - 字符：char(16位)\n   - 布尔：boolean\n\n2. 引用数据类型：\n   - 类、接口、数组、枚举\n\n【类型转换】\n```java\n// 自动类型转换（隐式）\nint a = 10;\nlong b = a; // int -> long\n\n// 强制类型转换（显式）\ndouble c = 3.14;\nint d = (int) c; // double -> int\n```\n\n【变量声明】\n```java\n// 局部变量\nint localVar = 10;\n\n// 实例变量\npublic class MyClass {\n    private int instanceVar;\n}\n\n// 静态变量\npublic class MyClass {\n    public static int staticVar;\n}\n```\n\n【常量】\n```java\n// final常量\nfinal int MAX_SIZE = 100;\n\n// 枚举常量\npublic enum Color {\n    RED, GREEN, BLUE\n}\n```"
        },
        {
          "id": 2,
          "title": "Java 面向对象的三大特性？",
          "answer": "【面向对象三大特性】\n1. 封装：隐藏内部实现，提供公共接口\n2. 继承：子类继承父类的属性和方法\n3. 多态：同一接口的不同实现\n\n【封装】\n```java\npublic class Student {\n    // 私有属性\n    private String name;\n    private int age;\n    \n    // 公共方法\n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n【继承】\n```java\n// 父类\npublic class Animal {\n    protected String name;\n    \n    public void eat() {\n        System.out.println(\"动物在吃东西\");\n    }\n}\n\n// 子类\npublic class Dog extends Animal {\n    public void bark() {\n        System.out.println(\"狗在叫\");\n    }\n    \n    @Override\n    public void eat() {\n        System.out.println(\"狗在吃骨头\");\n    }\n}\n```\n\n【多态】\n```java\n// 接口多态\npublic interface Shape {\n    double getArea();\n}\n\npublic class Circle implements Shape {\n    private double radius;\n    \n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Rectangle implements Shape {\n    private double width, height;\n    \n    @Override\n    public double getArea() {\n        return width * height;\n    }\n}\n\n// 使用多态\nShape shape1 = new Circle();\nShape shape2 = new Rectangle();\n```\n\n【抽象类和接口】\n```java\n// 抽象类\npublic abstract class AbstractAnimal {\n    protected String name;\n    \n    public abstract void makeSound();\n    \n    public void sleep() {\n        System.out.println(\"动物在睡觉\");\n    }\n}\n\n// 接口\npublic interface Flyable {\n    void fly();\n    \n    default void glide() {\n        System.out.println(\"滑翔\");\n    }\n}\n```"
        },
        {
          "id": 3,
          "title": "Java 8 新特性有哪些？",
          "answer": "【Java 8主要新特性】\n1. Lambda表达式：函数式编程\n2. Stream API：流式处理\n3. Optional类：空值处理\n4. 默认方法：接口默认实现\n5. 方法引用：简化Lambda\n6. 新的日期时间API：LocalDate、LocalTime\n7. CompletableFuture：异步编程\n\n【Lambda表达式】\n```java\n// 传统方式\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nfor (String name : names) {\n    System.out.println(name);\n}\n\n// Lambda表达式\nnames.forEach(name -> System.out.println(name));\nnames.forEach(System.out::println); // 方法引用\n```\n\n【Stream API】\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// 过滤偶数并求和\nint sum = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .mapToInt(Integer::intValue)\n    .sum();\n\n// 收集结果\nList<String> upperNames = names.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n```\n\n【Optional类】\n```java\n// 避免空指针异常\nOptional<String> optional = Optional.of(\"Hello\");\n\nString result = optional\n    .map(String::toUpperCase)\n    .orElse(\"Default\");\n\n// 链式调用\nOptional<User> user = findUserById(id);\nString email = user\n    .map(User::getEmail)\n    .orElse(\"No email\");\n```\n\n【新的日期时间API】\n```java\n// 当前日期\nLocalDate today = LocalDate.now();\nLocalTime now = LocalTime.now();\nLocalDateTime dateTime = LocalDateTime.now();\n\n// 创建特定日期\nLocalDate date = LocalDate.of(2023, 12, 25);\n\n// 日期计算\nLocalDate tomorrow = today.plusDays(1);\nLocalDate nextWeek = today.plusWeeks(1);\n\n// 格式化\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\nString formatted = today.format(formatter);\n```\n\n【CompletableFuture】\n```java\n// 异步执行\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // 模拟耗时操作\n    Thread.sleep(1000);\n    return \"Hello World\";\n});\n\n// 处理结果\nfuture.thenAccept(result -> System.out.println(result))\n    .exceptionally(throwable -> {\n        System.err.println(\"Error: \" + throwable.getMessage());\n        return null;\n    });\n```"
        }
      ]
    },
    {
      "id": "collection",
      "name": "集合框架专题",
      "questions": [
        {
          "id": 4,
          "title": "Java 集合框架的底层原理？",
          "answer": "【Java集合框架结构】\n1. Collection接口：单列集合\n   - List：有序、可重复\n   - Set：无序、不可重复\n   - Queue：队列\n\n2. Map接口：双列集合\n   - HashMap：哈希表实现\n   - TreeMap：红黑树实现\n   - LinkedHashMap：链表+哈希表\n\n【List实现原理】\n```java\n// ArrayList：动态数组\npublic class ArrayList<E> {\n    private Object[] elementData;\n    private int size;\n    \n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);\n        elementData[size++] = e;\n        return true;\n    }\n}\n\n// LinkedList：双向链表\npublic class LinkedList<E> {\n    private Node<E> first;\n    private Node<E> last;\n    \n    private static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n    }\n}\n```\n\n【Set实现原理】\n```java\n// HashSet：基于HashMap\npublic class HashSet<E> {\n    private HashMap<E, Object> map;\n    private static final Object PRESENT = new Object();\n    \n    public boolean add(E e) {\n        return map.put(e, PRESENT) == null;\n    }\n}\n\n// TreeSet：基于TreeMap（红黑树）\npublic class TreeSet<E> {\n    private TreeMap<E, Object> map;\n}\n```\n\n【HashMap原理】\n```java\n// JDK 1.8 HashMap结构\npublic class HashMap<K,V> {\n    // 数组+链表+红黑树\n    Node<K,V>[] table;\n    \n    static class Node<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n    }\n    \n    // 红黑树节点\n    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;\n        TreeNode<K,V> left;\n        TreeNode<K,V> right;\n        TreeNode<K,V> prev;\n        boolean red;\n    }\n}\n```\n\n【扩容机制】\n```java\n// HashMap扩容\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    \n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // 双倍扩容\n    }\n}\n```\n\n【性能对比】\n- ArrayList：随机访问O(1)，插入删除O(n)\n- LinkedList：随机访问O(n)，插入删除O(1)\n- HashMap：查找、插入、删除O(1)\n- TreeMap：查找、插入、删除O(log n)"
        },
        {
          "id": 5,
          "title": "HashMap 和 ConcurrentHashMap 区别？",
          "answer": "【HashMap特点】\n1. 非线程安全：多线程环境下可能产生数据不一致\n2. 允许null键值：key和value都可以为null\n3. 无序：不保证元素的存储顺序\n4. 快速访问：O(1)时间复杂度\n\n【ConcurrentHashMap特点】\n1. 线程安全：使用分段锁或CAS保证线程安全\n2. 不允许null键值：key和value都不能为null\n3. 高并发：支持高并发读写\n4. 性能优秀：比Hashtable性能更好\n\n【实现原理对比】\n```java\n// HashMap (JDK 1.8)\npublic class HashMap<K,V> {\n    Node<K,V>[] table; // 数组+链表+红黑树\n    \n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n}\n\n// ConcurrentHashMap (JDK 1.8)\npublic class ConcurrentHashMap<K,V> {\n    Node<K,V>[] table;\n    \n    public V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n    \n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());\n        \n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                // CAS操作插入新节点\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))\n                    break;\n            }\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n            else {\n                // 链表或红黑树插入\n                synchronized (f) {\n                    // 同步块保证线程安全\n                }\n            }\n        }\n    }\n}\n```\n\n【分段锁机制（JDK 1.7）】\n```java\n// JDK 1.7 ConcurrentHashMap\npublic class ConcurrentHashMap<K, V> {\n    final Segment<K,V>[] segments; // 分段数组\n    \n    static final class Segment<K,V> extends ReentrantLock {\n        transient volatile HashEntry<K,V>[] table;\n        transient int count;\n        transient int modCount;\n    }\n    \n    public V put(K key, V value) {\n        Segment<K,V> s;\n        if (value == null)\n            throw new NullPointerException();\n        int hash = hash(key);\n        int j = (hash >>> segmentShift) & segmentMask;\n        if ((s = (Segment<K,V>)UNSAFE.getObject(segments, (j << SSHIFT) + SBASE)) == null)\n            s = ensureSegment(j);\n        return s.put(key, hash, value, false);\n    }\n}\n```\n\n【CAS机制（JDK 1.8）】\n```java\n// CAS操作\nstatic final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n                                    Node<K,V> c, Node<K,V> v) {\n    return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n}\n\n// 获取节点\nstatic final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n    return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);\n}\n```\n\n【使用场景】\n- HashMap：单线程环境，性能要求高\n- ConcurrentHashMap：多线程环境，需要线程安全\n- Hashtable：不推荐使用，性能较差\n\n【性能对比】\n- HashMap：最快，但非线程安全\n- ConcurrentHashMap：线程安全，性能好\n- Hashtable：线程安全，性能差"
        }
      ]
    },
    {
      "id": "thread",
      "name": "多线程专题",
      "questions": [
        {
          "id": 6,
          "title": "Java 多线程的实现方式？",
          "answer": "【Java多线程实现方式】\n1. 继承Thread类\n2. 实现Runnable接口\n3. 实现Callable接口\n4. 使用线程池\n\n【继承Thread类】\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"线程执行: \" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\nMyThread thread = new MyThread();\nthread.start();\n```\n\n【实现Runnable接口】\n```java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"线程执行: \" + Thread.currentThread().getName());\n    }\n}\n\n// 使用\nThread thread = new Thread(new MyRunnable());\nthread.start();\n\n// Lambda表达式\nThread thread = new Thread(() -> {\n    System.out.println(\"Lambda线程\");\n});\nthread.start();\n```\n\n【实现Callable接口】\n```java\npublic class MyCallable implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        Thread.sleep(1000);\n        return \"Callable结果\";\n    }\n}\n\n// 使用\nFutureTask<String> futureTask = new FutureTask<>(new MyCallable());\nThread thread = new Thread(futureTask);\nthread.start();\n\n// 获取结果\nString result = futureTask.get();\n```\n\n【线程池】\n```java\n// 创建线程池\nExecutorService executor = Executors.newFixedThreadPool(10);\n\n// 提交任务\nexecutor.submit(() -> {\n    System.out.println(\"线程池任务\");\n});\n\n// 关闭线程池\nexecutor.shutdown();\n```\n\n【线程状态】\n1. NEW：新建状态\n2. RUNNABLE：可运行状态\n3. BLOCKED：阻塞状态\n4. WAITING：等待状态\n5. TIMED_WAITING：超时等待\n6. TERMINATED：终止状态\n\n【线程生命周期】\n```java\nThread thread = new Thread(() -> {\n    try {\n        Thread.sleep(1000); // TIMED_WAITING\n        synchronized (this) {\n            wait(); // WAITING\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n});\n\nthread.start(); // NEW -> RUNNABLE\n// 线程执行完毕后 TERMINATED\n```"
        },
        {
          "id": 7,
          "title": "线程池的原理和使用场景？",
          "answer": "【线程池原理】\n线程池通过预先创建一定数量的线程，复用这些线程来执行任务，避免频繁创建和销毁线程的开销。\n\n【核心参数】\n```java\npublic ThreadPoolExecutor(\n    int corePoolSize,        // 核心线程数\n    int maximumPoolSize,     // 最大线程数\n    long keepAliveTime,      // 线程空闲时间\n    TimeUnit unit,           // 时间单位\n    BlockingQueue<Runnable> workQueue,  // 工作队列\n    ThreadFactory threadFactory,        // 线程工厂\n    RejectedExecutionHandler handler    // 拒绝策略\n);\n```\n\n【工作流程】\n1. 提交任务到线程池\n2. 如果核心线程数未满，创建新线程\n3. 如果核心线程数已满，任务进入队列\n4. 如果队列已满，创建新线程（不超过最大线程数）\n5. 如果达到最大线程数，执行拒绝策略\n\n【常用线程池】\n```java\n// 固定大小线程池\nExecutorService fixedPool = Executors.newFixedThreadPool(10);\n\n// 缓存线程池\nExecutorService cachedPool = Executors.newCachedThreadPool();\n\n// 单线程池\nExecutorService singlePool = Executors.newSingleThreadExecutor();\n\n// 定时线程池\nScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(5);\n```\n\n【自定义线程池】\n```java\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n    5,                      // 核心线程数\n    10,                     // 最大线程数\n    60L,                    // 空闲时间\n    TimeUnit.SECONDS,       // 时间单位\n    new LinkedBlockingQueue<>(100),  // 工作队列\n    new ThreadFactory() {   // 线程工厂\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r);\n            t.setName(\"CustomThread-\" + t.getId());\n            return t;\n        }\n    },\n    new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略\n);\n```\n\n【拒绝策略】\n1. AbortPolicy：抛出异常（默认）\n2. CallerRunsPolicy：调用者线程执行\n3. DiscardPolicy：丢弃任务\n4. DiscardOldestPolicy：丢弃最旧任务\n\n【使用场景】\n- 固定大小线程池：CPU密集型任务\n- 缓存线程池：IO密集型任务\n- 单线程池：需要顺序执行的任务\n- 定时线程池：定时任务、周期性任务\n\n【最佳实践】\n- 合理设置线程池大小\n- 选择合适的队列类型\n- 设置合理的拒绝策略\n- 监控线程池状态"
        },
        {
          "id": 8,
          "title": "Java 中的volatile关键字作用？",
          "answer": "【volatile关键字作用】\n1. 保证可见性：一个线程对volatile变量的修改，其他线程立即可见\n2. 禁止指令重排：防止JVM对volatile变量的读写操作进行重排序\n3. 不保证原子性：volatile不能保证复合操作的原子性\n\n【可见性问题】\n```java\n// 没有volatile的问题\npublic class VisibilityProblem {\n    private boolean flag = false;  // 没有volatile\n    \n    public void setFlag() {\n        flag = true;\n    }\n    \n    public boolean getFlag() {\n        return flag;\n    }\n}\n\n// 线程A\nnew Thread(() -> {\n    while (!visibilityProblem.getFlag()) {\n        // 可能永远循环，因为看不到flag的变化\n    }\n    System.out.println(\"Flag changed!\");\n}).start();\n\n// 线程B\nnew Thread(() -> {\n    Thread.sleep(1000);\n    visibilityProblem.setFlag();\n}).start();\n```\n\n【volatile解决可见性】\n```java\npublic class VisibilitySolution {\n    private volatile boolean flag = false;  // 添加volatile\n    \n    public void setFlag() {\n        flag = true;\n    }\n    \n    public boolean getFlag() {\n        return flag;\n    }\n}\n```\n\n【指令重排问题】\n```java\n// 双重检查锁定（DCL）\npublic class Singleton {\n    private volatile static Singleton instance;  // volatile防止重排\n    \n    private Singleton() {}\n    \n    public static Singleton getInstance() {\n        if (instance == null) {  // 第一次检查\n            synchronized (Singleton.class) {\n                if (instance == null) {  // 第二次检查\n                    instance = new Singleton();  // 可能重排\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n【内存屏障】\nvolatile通过内存屏障实现可见性和禁止重排：\n```java\n// 写操作\npublic void write() {\n    flag = true;  // StoreStore + StoreLoad\n}\n\n// 读操作\npublic boolean read() {\n    return flag;  // LoadLoad + LoadStore\n}\n```\n\n【volatile vs synchronized】\n| 特性 | volatile | synchronized |\n|------|----------|-------------|\n| 可见性 | ✓ | ✓ |\n| 原子性 | ✗ | ✓ |\n| 有序性 | ✓ | ✓ |\n| 性能 | 好 | 差 |\n\n【使用场景】\n- 单次读写操作\n- 状态标志位\n- 双重检查锁定\n- 一写多读场景\n\n【注意事项】\n- 不能保证原子性\n- 不适合复合操作\n- 性能比synchronized好\n- 不能替代synchronized"
        },
        {
          "id": 9,
          "title": "Java 中的synchronized和Lock区别？",
          "answer": "【synchronized特点】\n1. 关键字：Java内置关键字\n2. 自动释放：方法或代码块执行完毕后自动释放锁\n3. 可重入：同一个线程可以多次获取同一把锁\n4. 非公平：不保证等待线程的获取顺序\n5. 不可中断：等待锁的线程不可被中断\n\n【Lock特点】\n1. 接口：java.util.concurrent.locks.Lock接口\n2. 手动释放：需要手动调用unlock()释放锁\n3. 可重入：ReentrantLock支持可重入\n4. 可公平：可以选择公平或非公平模式\n5. 可中断：支持中断等待的线程\n\n【代码对比】\n```java\n// synchronized\npublic class SynchronizedExample {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n    \n    public void incrementBlock() {\n        synchronized (this) {\n            count++;\n        }\n    }\n}\n\n// Lock\npublic class LockExample {\n    private int count = 0;\n    private final Lock lock = new ReentrantLock();\n    \n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();  // 必须手动释放\n        }\n    }\n}\n```\n\n【ReentrantLock高级特性】\n```java\npublic class AdvancedLockExample {\n    private final ReentrantLock lock = new ReentrantLock(true);  // 公平锁\n    private final Condition condition = lock.newCondition();\n    \n    public void await() throws InterruptedException {\n        lock.lock();\n        try {\n            condition.await();  // 等待条件\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void signal() {\n        lock.lock();\n        try {\n            condition.signal();  // 唤醒等待的线程\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public boolean tryLock() {\n        return lock.tryLock();  // 尝试获取锁\n    }\n    \n    public boolean tryLockWithTimeout(long time, TimeUnit unit) throws InterruptedException {\n        return lock.tryLock(time, unit);  // 超时获取锁\n    }\n}\n```\n\n【读写锁】\n```java\npublic class ReadWriteLockExample {\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final Lock readLock = lock.readLock();\n    private final Lock writeLock = lock.writeLock();\n    private Map<String, String> data = new HashMap<>();\n    \n    public String read(String key) {\n        readLock.lock();\n        try {\n            return data.get(key);\n        } finally {\n            readLock.unlock();\n        }\n    }\n    \n    public void write(String key, String value) {\n        writeLock.lock();\n        try {\n            data.put(key, value);\n        } finally {\n            writeLock.unlock();\n        }\n    }\n}\n```\n\n【性能对比】\n- synchronized：JVM优化，性能较好\n- Lock：功能丰富，性能略差\n\n【选择建议】\n- 简单场景：synchronized\n- 复杂场景：Lock（需要超时、中断、公平性等）\n- 读写分离：ReadWriteLock\n- 性能要求高：synchronized"
        },
        {
          "id": 10,
          "title": "Java 如何实现线程安全的单例模式？",
          "answer": "【单例模式实现方式】\n1. 饿汉式：线程安全，但可能浪费内存\n2. 懒汉式：需要同步，性能较差\n3. 双重检查锁定：性能好，但需要volatile\n4. 静态内部类：推荐使用\n5. 枚举：最简单，自动线程安全\n\n【饿汉式】\n```java\npublic class HungrySingleton {\n    // 类加载时就初始化\n    private static final HungrySingleton instance = new HungrySingleton();\n    \n    private HungrySingleton() {}\n    \n    public static HungrySingleton getInstance() {\n        return instance;\n    }\n}\n```\n\n【懒汉式（线程不安全）】\n```java\npublic class LazySingleton {\n    private static LazySingleton instance;\n    \n    private LazySingleton() {}\n    \n    public static LazySingleton getInstance() {\n        if (instance == null) {  // 多线程可能创建多个实例\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n```\n\n【懒汉式（线程安全）】\n```java\npublic class ThreadSafeLazySingleton {\n    private static ThreadSafeLazySingleton instance;\n    \n    private ThreadSafeLazySingleton() {}\n    \n    public static synchronized ThreadSafeLazySingleton getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeLazySingleton();\n        }\n        return instance;\n    }\n}\n```\n\n【双重检查锁定（DCL）】\n```java\npublic class DCLSingleton {\n    private volatile static DCLSingleton instance;  // volatile防止重排\n    \n    private DCLSingleton() {}\n    \n    public static DCLSingleton getInstance() {\n        if (instance == null) {  // 第一次检查\n            synchronized (DCLSingleton.class) {\n                if (instance == null) {  // 第二次检查\n                    instance = new DCLSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n【静态内部类】\n```java\npublic class StaticInnerSingleton {\n    private StaticInnerSingleton() {}\n    \n    // 静态内部类，延迟加载\n    private static class SingletonHolder {\n        private static final StaticInnerSingleton INSTANCE = new StaticInnerSingleton();\n    }\n    \n    public static StaticInnerSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n【枚举方式】\n```java\npublic enum EnumSingleton {\n    INSTANCE;  // 单例实例\n    \n    public void doSomething() {\n        System.out.println(\"枚举单例方法\");\n    }\n}\n\n// 使用\nEnumSingleton.INSTANCE.doSomething();\n```\n\n【序列化问题】\n```java\npublic class SerializableSingleton implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private static SerializableSingleton instance = new SerializableSingleton();\n    \n    private SerializableSingleton() {}\n    \n    public static SerializableSingleton getInstance() {\n        return instance;\n    }\n    \n    // 防止反序列化创建新实例\n    private Object readResolve() {\n        return instance;\n    }\n}\n```\n\n【反射攻击防护】\n```java\npublic class ReflectionSafeSingleton {\n    private static ReflectionSafeSingleton instance;\n    private static boolean initialized = false;\n    \n    private ReflectionSafeSingleton() {\n        if (initialized) {\n            throw new RuntimeException(\"单例已被创建\");\n        }\n        initialized = true;\n    }\n    \n    public static ReflectionSafeSingleton getInstance() {\n        if (instance == null) {\n            synchronized (ReflectionSafeSingleton.class) {\n                if (instance == null) {\n                    instance = new ReflectionSafeSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n【推荐使用】\n- 简单场景：枚举方式\n- 需要延迟加载：静态内部类\n- 需要序列化：实现readResolve方法\n- 防止反射攻击：添加标志位检查"
        }
      ]
    },
    {
      "id": "jvm",
      "name": "JVM专题",
      "questions": [
        {
          "id": 11,
          "title": "JVM 内存模型和垃圾回收机制？",
          "answer": "【JVM内存模型】\n1. 程序计数器：线程私有，记录当前线程执行的字节码行号，唯一不会OOM的区域\n2. Java虚拟机栈：线程私有，存储栈帧（局部变量表/操作数栈/动态链接/方法出口）\n3. 本地方法栈：为Native方法服务\n4. 堆：线程共享，存放对象实例，GC主要区域\n5. 方法区：存储类信息、常量、静态变量，JDK8后由元空间实现\n\n【垃圾回收机制】\n1. 分代收集：新生代（Eden/Survivor）和老年代\n2. 回收算法：标记-清除（碎片问题）、标记-整理（解决碎片）、复制算法（新生代）\n3. 垃圾收集器：Serial（单线程）、Parallel（吞吐优先）、CMS（低停顿）、G1（区域分代）、ZGC（超低延迟）\n4. 内存分配策略：对象优先Eden、大对象直接老年代、长期存活进老年代（默认15次GC）\n\n【GC日志分析】\n[GC (Allocation Failure) [PSYoungGen: 65536K->10752K(76288K)] 表示新生代GC，65M->10M，总76M\n\n【调优建议】\n- 合理设置堆大小：-Xms初始堆 -Xmx最大堆\n- 调整新生代比例：-XX:NewRatio\n- 选择合适收集器：-XX:+UseG1GC"
        },
        {
          "id": 12,
          "title": "Java 反射和注解的应用？",
          "answer": "【反射原理】\n在运行时获取类信息并操作类成员，核心类：Class、Field、Method、Constructor\n\n【反射应用】\n1. 动态创建对象：Class.forName(\"com.example.User\").newInstance()\n2. 调用私有方法：method.setAccessible(true); method.invoke(obj)\n3. 获取注解信息：field.getAnnotation(MyAnnotation.class)\n4. 框架集成：Spring IOC容器依赖反射\n\n【注解应用】\n1. 标记注解：@Override @Deprecated\n2. 元注解：@Target @Retention\n3. 自定义注解：\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface LogExecutionTime {}\n\n4. 注解处理器：通过反射运行时处理\n5. 框架集成：Spring @Autowired, JPA @Entity\n\n【实际场景】\n- ORM框架映射表字段\n- JUnit测试方法标识\n- Spring MVC请求映射\n- AOP切面编程\n\n【性能注意】\n反射比直接调用慢，生产环境慎用"
        },
        {
          "id": 13,
          "title": "Java IO/NIO/AIO 区别？",
          "answer": "【BIO（阻塞IO）】\n1. 同步阻塞模型，1请求=1线程\n2. 代码简单，连接多时资源消耗大\n3. 典型类：InputStream/OutputStream\n\n【NIO（非阻塞IO）】\n1. 同步非阻塞，基于Channel/Buffer/Selector\n2. 多路复用，单线程处理多连接\n3. 核心组件：\n- Buffer：数据缓冲区\n- Channel：双向数据传输通道\n- Selector：监听多个Channel事件\n4. 适用高并发场景，Netty基于NIO\n\n【AIO（异步IO）】\n1. 异步非阻塞，回调机制\n2. 内核完成操作后通知应用\n3. 类：AsynchronousSocketChannel\n\n【对比总结】\n| 特性 | BIO | NIO | AIO |\n|------|-----|-----|-----|\n| 模型 | 同步阻塞 | 同步非阻塞 | 异步非阻塞 |\n| 线程 | 1连接1线程 | 1线程多连接 | 回调机制 |\n| 复杂度 | 低 | 高 | 高 |\n| 吞吐量 | 低 | 高 | 高 |\n| 适用场景 | 连接少 | 高并发 | 高性能 |"
        }
      ]
    }
  ]
} 